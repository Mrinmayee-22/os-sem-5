================================================================================
FILE 1: banker.c
================================================================================
#include <stdio.h>

int main() {
    int n, m;
    printf("Enter number of processes: ");
    scanf("%d", &n);
    printf("Enter number of resource types: ");
    scanf("%d", &m);

    int alloc[n][m], max[n][m], need[n][m], avail[m];
    int i, j;

    // Input Allocation Matrix
    printf("Enter Allocation Matrix:\n");
    for(i = 0; i < n; i++)
        for(j = 0; j < m; j++)
            scanf("%d", &alloc[i][j]);

    // Input Max Matrix
    printf("Enter Max Matrix:\n");
    for(i = 0; i < n; i++)
        for(j = 0; j < m; j++)
            scanf("%d", &max[i][j]);

    // Calculate Need Matrix
    for(i = 0; i < n; i++)
        for(j = 0; j < m; j++)
            need[i][j] = max[i][j] - alloc[i][j];

    // Input Available Resources
    printf("Enter Available Resources:\n");
    for(j = 0; j < m; j++)
        scanf("%d", &avail[j]);

    // Safety Algorithm
    int finish[n], safeSeq[n], count = 0;
    for(i = 0; i < n; i++)
        finish[i] = 0;

    int found;
    while(count < n) {
        found = 0;
        for(i = 0; i < n; i++) {
            if(finish[i] == 0) {
                int flag = 1;
                for(j = 0; j < m; j++) {
                    if(need[i][j] > avail[j]) {
                        flag = 0;
                        break;
                    }
                }
                if(flag) {
                    for(j = 0; j < m; j++)
                        avail[j] += alloc[i][j];
                    safeSeq[count++] = i;
                    finish[i] = 1;
                    found = 1;
                }
            }
        }
        if(!found) {
            printf("System is not in a safe state.\n");
            return 0;
        }
    }

    printf("System is in a safe state.\nSafe sequence is: ");
    for(i = 0; i < n; i++)
        printf("P%d ", safeSeq[i]);
    printf("\n");

    // Resource Request Algorithm
    int req_proc, request[m];
    printf("\nEnter process number for resource request (0 to %d): ", n-1);
    scanf("%d", &req_proc);
    printf("Enter resource request for process %d:\n", req_proc);
    for(j = 0; j < m; j++)
        scanf("%d", &request[j]);

    // Check if request <= need
    int can_grant = 1;
    for(j = 0; j < m; j++) {
        if(request[j] > need[req_proc][j]) {
            can_grant = 0;
            break;
        }
    }
    if(!can_grant) {
        printf("Error: Process has exceeded its maximum claim.\n");
        return 0;
    }

    // Check if request <= available
    for(j = 0; j < m; j++) {
        if(request[j] > avail[j]) {
            can_grant = 0;
            break;
        }
    }
    if(!can_grant) {
        printf("Resources are not available. Process must wait.\n");
        return 0;
    }

    // Pretend to allocate requested resources
    for(j = 0; j < m; j++) {
        avail[j] -= request[j];
        alloc[req_proc][j] += request[j];
        need[req_proc][j] -= request[j];
    }

    // Safety check after allocation
    for(i = 0; i < n; i++)
        finish[i] = 0;
    count = 0;
    int avail_temp[m];
    for(j = 0; j < m; j++)
        avail_temp[j] = avail[j];

    while(count < n) {
        found = 0;
        for(i = 0; i < n; i++) {
            if(finish[i] == 0) {
                int flag = 1;
                for(j = 0; j < m; j++) {
                    if(need[i][j] > avail_temp[j]) {
                        flag = 0;
                        break;
                    }
                }
                if(flag) {
                    for(j = 0; j < m; j++)
                        avail_temp[j] += alloc[i][j];
                    finish[i] = 1;
                    found = 1;
                    count++;
                }
            }
        }
        if(!found) {
            printf("After resource request, system is NOT in a safe state. Request cannot be granted.\n");
            return 0;
        }
    }
    printf("After resource request, system is STILL in a safe state. Request can be granted.\n");

    return 0;
}

================================================================================
FILE 2: calculator.sh
================================================================================
#!/bin/bash

while true
do
# Take user input
echo "Enter two numbers:"
read a
read b

# Input type of operation
echo "Enter choice:"
echo "1. Addition"
echo "2. Subtraction"
echo "3. Multiplication"
echo "4. Division"
echo "5. Exit"
read ch

# Perform calculator operations using case statement
case $ch in
  1)
    res=$(echo "$a + $b" | bc)
    ;;
  2)
    res=$(echo "$a - $b" | bc)
    ;;
  3)
    res=$(echo "$a * $b" | bc)
    ;;
  4)
    # Check for division by zero
    if [ "$b" -eq 0 ]; then
      echo "Error: Division by zero"
      exit 1
    fi
    res=$(echo "scale=2; $a / $b" | bc)
    ;;
  5)
	echo "Exit"
	break
  	;;
  *)
    echo "Invalid choice"
    exit 1
    ;;
esac

echo "Result: $res"
done

================================================================================
FILE 3: fifo.c
================================================================================
#include <stdio.h>
#include <stdlib.h>

// Function to check if a page is present in memory
int isPagePresent(int page, int frames[], int numFrames)
{
    for (int i = 0; i < numFrames; i++)
    {
        if (frames[i] == page)
        {
            return 1; // Page found
        }
    }
    return 0; // Page not found
}

// Function to display current state of frames
void displayFrames(int frames[], int numFrames)
{
    printf("Frames: ");
    for (int i = 0; i < numFrames; i++)
    {
        if (frames[i] == -1)
        {
            printf("[ ] ");
        }
        else
        {
            printf("[%d] ", frames[i]);
        }
    }
    printf("\n");
}

// FIFO Page Replacement Algorithm
void fifoPageReplacement(int pages[], int numPages, int numFrames)
{
    int frames[numFrames];
    int pageFaults = 0;
    int pageHits = 0;
    int front = 0; // Points to the oldest page (next to be replaced)

    // Initialize all frames to -1 (empty)
    for (int i = 0; i < numFrames; i++)
    {
        frames[i] = -1;
    }

    printf("\n=== FIFO Page Replacement Algorithm ===\n");
    printf("Number of Frames: %d\n", numFrames);
    printf("Reference String: ");
    for (int i = 0; i < numPages; i++)
    {
        printf("%d ", pages[i]);
    }
    printf("\n\n");

    printf("Step-by-step execution:\n");
    printf("%-10s %-15s %-10s\n", "Page", "Frames", "Status");
    printf("----------------------------------------\n");

    for (int i = 0; i < numPages; i++)
    {
        int currentPage = pages[i];
        printf("%-10d ", currentPage);

        if (isPagePresent(currentPage, frames, numFrames))
        {
            // Page hit
            pageHits++;
            displayFrames(frames, numFrames);
            printf("HIT\n");
        }
        else
        {
            // Page fault
            pageFaults++;
            frames[front] = currentPage;
            front = (front + 1) % numFrames; 
            displayFrames(frames, numFrames);
            printf("FAULT\n");
        }
    }

    // Display results
    printf("\n=== Results ===\n");
    printf("Total Page Faults: %d\n", pageFaults);
    printf("Total Page Hits: %d\n", pageHits);
    printf("Page Fault Ratio: %.2f%%\n", ((float)pageFaults / numPages) * 100);
    printf("Page Hit Ratio: %.2f%%\n", ((float)pageHits / numPages) * 100);
}

int main()
{
    int numFrames, numPages;

    printf("=== FIFO Page Replacement Algorithm ===\n\n");

    // Get number of frames from user
    printf("Enter the number of frames: ");
    scanf("%d", &numFrames);

    if (numFrames <= 0)
    {
        printf("Error: Number of frames must be positive!\n");
        return 1;
    }

    printf("Enter the number of pages in reference string: ");
    scanf("%d", &numPages);

    if (numPages <= 0)
    {
        printf("Error: Number of pages must be positive!\n");
        return 1;
    }
    int *pages = (int *)malloc(numPages * sizeof(int));
    if (pages == NULL)
    {
        printf("Error: Memory allocation failed!\n");
        return 1;
    }

    // Get reference string from user
    printf("Enter the reference string (space-separated page numbers):\n");
    for (int i = 0; i < numPages; i++)
    {
        scanf("%d", &pages[i]);
        if (pages[i] < 0)
        {
            printf("Error: Page numbers must be non-negative!\n");
            free(pages);
            return 1;
        }
    }

    // Execute FIFO algorithm
    fifoPageReplacement(pages, numPages, numFrames);

    // Free allocated memory
    free(pages);

    printf("\nPress Enter to exit...");
    getchar(); // Consume newline
    getchar(); // Wait for user input

    return 0;
}

================================================================================
FILE 4: fork.c
================================================================================
/* #include <stdio.h>
#include <unistd.h>  

int main() 
{
    int pid = fork();  

    if (pid < 0) {
        printf("Fork failed!\n");
        return 1;
    } else {
        printf("Hello World\n");
    }

    return 0;
} */


/* #include <stdio.h>
#include <unistd.h>  // for fork()
#include <sys/types.h> // for pid_t

int main() {
    int number;

    printf("Enter a number: ");
    scanf("%d", &number);

    pid_t pid = fork();

    if (pid < 0) {
        // fork failed
        printf("Fork failed!\n");
        return 1;
    } else if (pid == 0) {
        // Child process
        if (number % 2 == 0) {
            printf("Hello from child\n");
            printf("This number is even\n");
        }
    } else {
        // Parent process
        if (number % 2 != 0) {
            printf("Hello from parent\n");
            printf("This number is odd\n");
        }
    }

    return 0;
}
*/


#include <stdio.h>
#include <unistd.h>   // for fork()

// Function to sort in ascending order (child process)
void AscendingBubbleSort(int arr[], int n) {
    int temp;
    for(int i = 0; i < n - 1; i++) {
        for(int j = 0; j < n - i - 1; j++) {
            if(arr[j] > arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    printf("Child Process - Ascending Order: ");
    for(int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Function to sort in descending order (parent process)
void DescendingBubbleSort(int arr[], int n) {
    int temp;
    for(int i = 0; i < n - 1; i++) {
        for(int j = 0; j < n - i - 1; j++) {
            if(arr[j] < arr[j+1]) {
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    printf("Parent Process - Descending Order: ");
    for(int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int arr[5];

    for(int i = 0; i < 5; i++) {
        printf("Enter a number: ");
        scanf("%d", &arr[i]);  
    }

    int pid = fork();

    if(pid < 0) {
        printf("Fork failed!\n");
        return 1;
    } else if(pid == 0) {
        // Child process
        AscendingBubbleSort(arr, 5);
    } else {
        // Parent process
        DescendingBubbleSort(arr, 5);
    }

    return 0;
}

================================================================================
FILE 5: ipc.c
================================================================================
#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <unistd.h>
#include <stdlib.h>
#define MAX 20
int main()
{
    int filedes[2], n;
    char string[MAX];
    char line[MAX];
    pid_t pid;

    printf("enter the string to be given to the parent: ");
    fflush(stdin);
    scanf("%s", string);

    if ((pipe(filedes)) != 0)
    {
        printf("\n pipe creation error");
        exit(0);
    }

    if ((pid = fork()) < 0)
    {
        printf("\n fork error");
        exit(0);
    }

    if (pid > 0)
    {
        close(filedes[0]);
        write(filedes[1], string, MAX);
    }

    if (pid == 0)
    {
        close(filedes[1]);
        n = read(filedes[0], line, MAX);
        line[n] = '\0';
        printf("\n\n Data read by child is : %s\n", line);
    }
    exit(0);
}

================================================================================
FILE 6: lru.c
================================================================================
#include <stdio.h>
#include <stdlib.h>

// Function to check if a page is present in memory
int isPagePresent(int page, int frames[], int numFrames)
{
    for (int i = 0; i < numFrames; i++)
    {
        if (frames[i] == page)
        {
            return i; // Return index if page found
        }
    }
    return -1; // Page not found
}

// Function to display current state of frames
void displayFrames(int frames[], int numFrames)
{
    printf("Frames: ");
    for (int i = 0; i < numFrames; i++)
    {
        if (frames[i] == -1)
        {
            printf("[ ] ");
        }
        else
        {
            printf("[%d] ", frames[i]);
        }
    }
    printf("\n");
}

// Function to find the least recently used page index
int findLRU(int time[], int numFrames)
{
    int min = time[0], minIndex = 0;
    for (int i = 1; i < numFrames; i++)
    {
        if (time[i] < min)
        {
            min = time[i];
            minIndex = i;
        }
    }
    return minIndex;
}

// LRU Page Replacement Algorithm
void lruPageReplacement(int pages[], int numPages, int numFrames)
{
    int frames[numFrames];
    int time[numFrames]; // To keep track of when each frame was last used
    int pageFaults = 0;
    int pageHits = 0;
    int counter = 0; // Global counter for time tracking

    // Initialize all frames to -1 (empty) and time to 0
    for (int i = 0; i < numFrames; i++)
    {
        frames[i] = -1;
        time[i] = 0;
    }

    printf("\n=== LRU Page Replacement Algorithm ===\n");
    printf("Number of Frames: %d\n", numFrames);
    printf("Reference String: ");
    for (int i = 0; i < numPages; i++)
    {
        printf("%d ", pages[i]);
    }
    printf("\n\n");

    printf("Step-by-step execution:\n");
    printf("%-10s %-15s %-10s\n", "Page", "Frames", "Status");
    printf("----------------------------------------\n");

    for (int i = 0; i < numPages; i++)
    {
        int currentPage = pages[i];
        printf("%-10d ", currentPage);

        int pageIndex = isPagePresent(currentPage, frames, numFrames);

        if (pageIndex != -1)
        {
            // Page hit - update the time for this frame
            pageHits++;
            time[pageIndex] = ++counter;
            displayFrames(frames, numFrames);
            printf("HIT\n");
        }
        else
        {
            // Page fault
            pageFaults++;

            // Check if there's an empty frame
            int emptyFrame = -1;
            for (int j = 0; j < numFrames; j++)
            {
                if (frames[j] == -1)
                {
                    emptyFrame = j;
                    break;
                }
            }

            if (emptyFrame != -1)
            {
                // Use empty frame
                frames[emptyFrame] = currentPage;
                time[emptyFrame] = ++counter;
            }
            else
            {
                // All frames are full, find LRU page
                int lruIndex = findLRU(time, numFrames);
                frames[lruIndex] = currentPage;
                time[lruIndex] = ++counter;
            }

            displayFrames(frames, numFrames);
            printf("FAULT\n");
        }
    }

    // Display results
    printf("\n=== Results ===\n");
    printf("Total Page Faults: %d\n", pageFaults);
    printf("Total Page Hits: %d\n", pageHits);
    printf("Page Fault Ratio: %.2f%%\n", ((float)pageFaults / numPages) * 100);
    printf("Page Hit Ratio: %.2f%%\n", ((float)pageHits / numPages) * 100);
}

int main()
{
    int numFrames, numPages;

    printf("=== LRU Page Replacement Algorithm ===\n\n");

    // Get number of frames from user
    printf("Enter the number of frames: ");
    scanf("%d", &numFrames);

    if (numFrames <= 0)
    {
        printf("Error: Number of frames must be positive!\n");
        return 1;
    }

    // Get number of pages from user
    printf("Enter the number of pages in reference string: ");
    scanf("%d", &numPages);

    if (numPages <= 0)
    {
        printf("Error: Number of pages must be positive!\n");
        return 1;
    }

    // Allocate memory for pages array
    int *pages = (int *)malloc(numPages * sizeof(int));
    if (pages == NULL)
    {
        printf("Error: Memory allocation failed!\n");
        return 1;
    }

    // Get reference string from user
    printf("Enter the reference string (space-separated page numbers):\n");
    for (int i = 0; i < numPages; i++)
    {
        scanf("%d", &pages[i]);
        if (pages[i] < 0)
        {
            printf("Error: Page numbers must be non-negative!\n");
            free(pages);
            return 1;
        }
    }

    // Execute LRU algorithm
    lruPageReplacement(pages, numPages, numFrames);

    // Free allocated memory
    free(pages);

    printf("\nPress Enter to exit...");
    getchar(); // Consume newline
    getchar(); // Wait for user input

    return 0;
}

================================================================================
FILE 7: orphan.c
================================================================================
#include<sys/types.h>
#include<stdio.h>
#include<unistd.h>
#include<sys/wait.h>

int main()
{
int pid = fork();
if(pid>0)
{
printf("parent process id: %d\n", getpid());
printf("child process id: %d\n", pid);
}
else if(pid == 0)
{
sleep(5);
printf("\nchild process id: %d\n", getpid());
printf("parent process id: %d\n", getppid());
}
return 0;
}

================================================================================
FILE 8: reader_writer.c
================================================================================
#include<semaphore.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<pthread.h>

sem_t mutex, wrt;
pthread_t tid;
int sharedvar=99;
pthread_t writers[5], readers[5];
int readercount=0;

void reader(void param)
{
    sem_wait(&mutex);
    readercount++;
    if(readercount==1)
        sem_wait(&wrt);
    sem_post(&mutex);

    printf("\n%d reader is reading sharedvar=%d", readercount, sharedvar);

    sem_wait(&mutex);
    readercount--;
    if(readercount==0)
        sem_post(&wrt);
    sem_post(&mutex);

    printf("\n%d Reader is done", readercount+1);
}

void writer(void param)
{
    printf("\nWriter is trying to enter");
    sem_wait(&wrt);
    printf("\nWriter has entered CS");
    sharedvar++;
    printf("\nWriter CHANGED THE VALUE OF SHARED VAR TO %d", sharedvar);
    sem_post(&wrt);
    printf("\nWriter is out of CS");
}

int main()
{
    int n2, i;
    printf("Enter the number of readers:");
    scanf("%d", &n2);
    sem_init(&mutex, 0, 1);
    sem_init(&wrt, 0, 1);
    
    for(i = 0; i < n2; i++)
    {
        pthread_create(&writers[i], NULL, writer, NULL);
        pthread_create(&readers[i], NULL, reader, NULL);
    }

    for(i = 0; i < n2; i++)
    {
        pthread_join(writers[i], NULL);
        pthread_join(readers[i], NULL);
    }
}

================================================================================
FILE 9: srtf_fcfs.c
================================================================================
#include <stdio.h>

void printResults(int n, int pid[], int at[], int bt[], int ct[], int tat[], int wt[], float avg_wt, float avg_tat)
{
    printf("\nProcess\tAT\tBT\tCT\tTAT\tWT\n");
    for (int i = 0; i < n; i++)
    {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\n", pid[i], at[i], bt[i], ct[i], tat[i], wt[i]);
    }
    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", avg_tat / n);
}

void printGantt(int gantt_pid[], int gantt_start[], int gantt_end[], int g_count)
{
    printf("\n\nGantt Chart:\n");
    int final_pid[200], final_start[200], final_end[200], count = 0;

    final_pid[count] = gantt_pid[0];
    final_start[count] = gantt_start[0];
    final_end[count] = gantt_end[0];

    for (int i = 1; i < g_count; i++)
    {
        if (gantt_pid[i] == final_pid[count])
        {
            final_end[count] = gantt_end[i];
        }
        else
        {
            count++;
            final_pid[count] = gantt_pid[i];
            final_start[count] = gantt_start[i];
            final_end[count] = gantt_end[i];
        }
    }
    count++;

    // Print top border
    printf(" ");
    for (int i = 0; i < count; i++)
        printf(" -------");
    printf("\n|");

    // Print process labels
    for (int i = 0; i < count; i++)
    {
        if (final_pid[i] == -1)
            printf(" Idle  |");
        else
            printf("  P%-2d  |", final_pid[i]);
    }

    // Print bottom border
    printf("\n ");
    for (int i = 0; i < count; i++)
        printf(" -------");
    printf("\n");

    // Print timeline
    printf("%d", final_start[0]);
    for (int i = 0; i < count; i++)
    {
        printf("      %d", final_end[i]);
    }
    printf("\n");
}

void printSortedTable(int n, int pid[], int at[], int bt[])
{
    printf("\nSorted Input (by Arrival Time):\n");
    printf("Process\tAT\tBT\n");
    for (int i = 0; i < n; i++)
    {
        printf("P%d\t%d\t%d\n", pid[i], at[i], bt[i]);
    }
}

void sjf_nonpreemptive(int n, int pid[], int at[], int bt[])
{
    int ct[n], tat[n], wt[n], completed[n];
    float avg_wt = 0, avg_tat = 0;
    int time = 0, count = 0;

    for (int i = 0; i < n; i++)
        completed[i] = 0;

    int gantt_pid[2 * n], gantt_start[2 * n], gantt_end[2 * n], g_count = 0;

    while (count < n)
    {
        int idx = -1, min_bt = 9999;
        for (int i = 0; i < n; i++)
        {
            if (!completed[i] && at[i] <= time && bt[i] < min_bt)
            {
                min_bt = bt[i];
                idx = i;
            }
        }
        if (idx == -1)
        {
            gantt_pid[g_count] = -1;
            gantt_start[g_count] = time;
            time++;
            gantt_end[g_count++] = time;
        }
        else
        {
            gantt_pid[g_count] = pid[idx];
            gantt_start[g_count] = time;
            time += bt[idx];
            gantt_end[g_count++] = time;
            ct[idx] = time;
            tat[idx] = ct[idx] - at[idx];
            wt[idx] = tat[idx] - bt[idx];
            avg_wt += wt[idx];
            avg_tat += tat[idx];
            completed[idx] = 1;
            count++;
        }
    }
    printResults(n, pid, at, bt, ct, tat, wt, avg_wt, avg_tat);
    printGantt(gantt_pid, gantt_start, gantt_end, g_count);
}
void srtf_preemptive(int n, int pid[], int at[], int bt[])
{
    int rt[n], ct[n], tat[n], wt[n], done[n];
    int completed = 0, time = 0;
    float avg_wt = 0, avg_tat = 0;

    for (int i = 0; i < n; i++)
    {
        rt[i] = bt[i];
        done[i] = 0;
    }

    int gantt_pid[100], gantt_start[100], gantt_end[100], g_count = 0;

    while (completed < n)
    {
        int idx = -1, min_rt = 9999;
        for (int i = 0; i < n; i++)
        {
            if (at[i] <= time && !done[i] && rt[i] < min_rt)
            {
                min_rt = rt[i];
                idx = i;
            }
        }
        if (idx == -1)
        {
            gantt_pid[g_count] = -1;
            gantt_start[g_count] = time;
            time++;
            gantt_end[g_count++] = time;
        }
        else
        {
            gantt_pid[g_count] = pid[idx];
            gantt_start[g_count] = time;
            rt[idx]--;
            time++;
            gantt_end[g_count++] = time;
            if (rt[idx] == 0)
            {
                ct[idx] = time;
                tat[idx] = ct[idx] - at[idx];
                wt[idx] = tat[idx] - bt[idx];
                avg_wt += wt[idx];
                avg_tat += tat[idx];
                done[idx] = 1;
                completed++;
            }
        }
    }
    printResults(n, pid, at, bt, ct, tat, wt, avg_wt, avg_tat);
    printGantt(gantt_pid, gantt_start, gantt_end, g_count);
}

void fcfs_nonpreemptive(int n, int pid[], int at[], int bt[])
{
    int ct[n], tat[n], wt[n];
    float avg_wt = 0, avg_tat = 0;
    int gantt_pid[n], gantt_start[n], gantt_end[n], time = 0;

    for (int i = 0; i < n; i++)
    {
        if (time < at[i])
            time = at[i];
        gantt_pid[i] = pid[i];
        gantt_start[i] = time;
        time += bt[i];
        gantt_end[i] = time;
        ct[i] = time;
        tat[i] = ct[i] - at[i];
        wt[i] = tat[i] - bt[i];
        avg_wt += wt[i];
        avg_tat += tat[i];
}
    printResults(n, pid, at, bt, ct, tat, wt, avg_wt, avg_tat);
    printGantt(gantt_pid, gantt_start, gantt_end, n);
}

int main()
{
    int n;
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    int pid[n], at[n], bt[n];

    for (int i = 0; i < n; i++)
    {
        pid[i] = i + 1;
        printf("\nEnter Arrival Time of P%d: ", pid[i]);
        scanf("%d", &at[i]);
        printf("Enter Burst Time of P%d: ", pid[i]);
        scanf("%d", &bt[i]);
    }
    for (int i = 0; i < n - 1; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            if (at[i] > at[j])
            {
                int temp = at[i];
                at[i] = at[j];
                at[j] = temp;
                temp = bt[i];
                bt[i] = bt[j];
                bt[j] = temp;
                temp = pid[i];
                pid[i] = pid[j];
                pid[j] = temp;
            }
        }
    }

    printSortedTable(n, pid, at, bt);

    int choice;
    do
    {
        printf("\n\nChoose Scheduling Algorithm:\n");
        printf("1. SJF Non-Preemptive\n");
        printf("2. SRTF Preemptive\n");
        printf("3. FCFS Non-Preemptive\n");
        printf("4. Exit\n");
        printf("Enter choice: ");
        scanf("%d", &choice);

        switch (choice)
        {
        case 1:
            sjf_nonpreemptive(n, pid, at, bt);
            break;
        case 2:
            srtf_preemptive(n, pid, at, bt);
            break;
        case 3:
            fcfs_nonpreemptive(n, pid, at, bt);
            break;
        case 4:
            printf("Exiting...\n");
            break;
        default:
            printf("Invalid choice!\n");
        }
    } while (choice != 4);

    return 0;
}

================================================================================
FILE 10: zombie.c
================================================================================
#include<sys/types.h>
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
int main(void)
{
pid_t pid;
if((pid=fork())<0)
	printf("\t fork error\n");
else
{
if(pid==0)
	printf("child process id is %d\n", getpid());
else
{
	sleep(5);
	printf("****parent\n");
	system("ps -axj | tail");
}
}
exit(0);
}

================================================================================
FILE 11: odd_even.sh
================================================================================
#!/bin/bash

# Script to check if a number is odd or even

echo "Enter a number:"
read num

# Check if input is a valid number
if ! [[ "$num" =~ ^-?[0-9]+$ ]]; then
    echo "Error: Please enter a valid integer!"
    exit 1
fi

# Check if number is odd or even
if [ $((num % 2)) -eq 0 ]; then
    echo "$num is EVEN"
else
    echo "$num is ODD"
fi

# Additional information
if [ $num -gt 0 ]; then
    echo "The number is positive"
elif [ $num -lt 0 ]; then
    echo "The number is negative"
else
    echo "The number is zero (which is even)"
fi

================================================================================
FILE 12: reverse_string.sh
================================================================================
#!/bin/bash

# Script to reverse a string

echo "Enter a string to reverse:"
read str

# Method 1: Using rev command (if available)
if command -v rev &> /dev/null; then
    reversed=$(echo "$str" | rev)
    echo "Reversed string (using rev): $reversed"
else
    # Method 2: Using manual reversal
    len=${#str}
    reversed=""
    
    for (( i=$len-1; i>=0; i-- ))
    do
        reversed="$reversed${str:$i:1}"
    done
    
    echo "Reversed string: $reversed"
fi

# Alternative method using awk
echo "Reversed string (using awk): $(echo "$str" | awk '{ for(i=length;i>0;i--) printf "%s", substr($0,i,1); print "" }')"

================================================================================
FILE 13: print_odd_numbers.sh
================================================================================
#!/bin/bash

# Script to print odd numbers from 0 to 10

echo "Odd numbers from 0 to 10:"
echo "========================"

# Method 1: Using for loop with condition
for i in {0..10}
do
    if [ $((i % 2)) -ne 0 ]; then
        echo $i
    fi
done

echo ""
echo "Alternative method using seq:"
echo "============================="

# Method 2: Using seq with step
seq 1 2 10

echo ""
echo "Using while loop:"
echo "================="

# Method 3: Using while loop
num=1
while [ $num -le 10 ]
do
    echo $num
    num=$((num + 2))
done

================================================================================
FILE 14: greet_user.sh
================================================================================
#!/bin/bash

# Script to accept user name and greet them

echo "Enter your name:"
read name

# Check if name is empty
if [ -z "$name" ]; then
    echo "Error: Name cannot be empty!"
    exit 1
fi

# Greet the user
echo ""
echo "=============================="
echo "Hello, $name!"
echo "Welcome to the system!"
echo "=============================="

# Get current time and give appropriate greeting
hour=$(date +%H)

if [ $hour -lt 12 ]; then
    echo "Good Morning, $name!"
elif [ $hour -lt 18 ]; then
    echo "Good Afternoon, $name!"
else
    echo "Good Evening, $name!"
fi

# Display current date and time
echo ""
echo "Current date and time: $(date)"
echo "Have a great day, $name!"

================================================================================
                              END OF FILE COMPILATION
================================================================================
